(()=>{"use strict";const e={},t=[],s=[],a=[],n=1e4,r=2e3,i={common:{health:5,speed:.5,damage:5,probability:.4,color:"#808080"},uncommon:{health:40,speed:.75,damage:10,probability:.3,color:"#008000"},rare:{health:60,speed:1,damage:15,probability:.15,color:"#0000FF"},epic:{health:80,speed:1.25,damage:20,probability:.1,color:"#800080"},legendary:{health:100,speed:1.5,damage:25,probability:.04,color:"#FFA500"},mythic:{health:150,speed:2,damage:30,probability:.01,color:"#FF0000"}},o={common:{start:0,end:2e3},uncommon:{start:2e3,end:4e3},rare:{start:4e3,end:6e3},epic:{start:6e3,end:8e3},legendary:{start:8e3,end:9e3},mythic:{start:9e3,end:n}},l={common:1,uncommon:1.2,rare:1.4,epic:1.6,legendary:1.8,mythic:2},c=[];function d(){const e=function(e){const t=n/6,s=e*t;if(e>=4){const s=n-t/2*(6-e);return{x:s+Math.random()*(n-s),y:Math.random()*r}}return{x:s+Math.random()*t,y:Math.random()*r}}(Math.floor(6*Math.random()));return{x:e.x,y:e.y,scale:.5+1.5*Math.random()}}function h(){const e=n;return{x:c.length*e+Math.random()*e,y:Math.random()*r,radius:50+70*Math.random(),rotation:Math.random()*Math.PI*2}}class g{constructor(){this.connections=new Map,this.messageHandlers=[],this.server=null,"undefined"!=typeof self&&"undefined"==typeof Window&&"undefined"!=typeof WorkerGlobalScope&&this.initializeServer()}initializeServer(){try{const e=new MessageChannel;this.server=e.port1,this.server.onmessage=this.handleServerMessage.bind(this),this.server.start(),self.postMessage({type:"server_init",port:e.port2},[e.port2]),console.log("Server initialized")}catch(e){console.error("Failed to initialize server:",e)}}handleServerMessage(e){const{type:t,data:s,clientId:a}=e.data;switch(console.log("Server received message:",t,s,a),t){case"connection":this.handleNewConnection(a);break;case"message":this.handleClientMessage(a,s);break;case"disconnect":this.handleDisconnect(a)}}handleNewConnection(e){console.log("New connection:",e);const t=new MessageChannel;t.port1.onmessage=t=>{this.handleClientMessage(e,t.data)},t.port1.start(),this.connections.set(e,t.port1),self.postMessage({type:"client_connection",clientId:e,port:t.port2},[t.port2]),this.messageHandlers.forEach((t=>t({type:"connection",peerId:e})))}handleClientMessage(e,t){console.log("Client message received:",e,t),t.peerId=e,this.messageHandlers.forEach((e=>e(t)))}handleDisconnect(e){console.log("Client disconnected:",e);const t=this.connections.get(e);t&&(t.close(),this.connections.delete(e),this.messageHandlers.forEach((t=>t({type:"disconnect",peerId:e}))))}onMessage(e){this.messageHandlers.push(e)}isConnected(e){return this.connections.has(e)}sendToPeer(e,t){console.log("Sending to peer:",e,t);const s=this.connections.get(e);s?s.postMessage({type:"server_message",data:t}):console.error(`No active connection for peer ${e}`)}broadcast(e){console.log("Broadcasting message:",e),this.connections.forEach(((t,s)=>{console.log("Broadcasting to client:",s),t.postMessage({type:"server_message",data:e})}))}close(){this.connections.forEach((e=>{e.close()})),this.connections.clear(),this.messageHandlers=[],this.server&&(this.server.close(),this.server=null)}}const p=new class{constructor(){this.connections=new Map,this.isRunning=!1,this.decorations=[],this.sands=[],this.ENEMY_COUNT=200,this.signalingServer=null,this.serverAddress="",this.authenticatedUsers=new Map,this.userCredentials=new Map,this.db=null,this.DB_NAME="GameServerDB",this.STORE_NAME="credentials",this.initializeGameState(),this.initDatabase().then((()=>{this.loadUserCredentials()})).catch((e=>{console.error("Failed to initialize database:",e)}))}initDatabase(){return new Promise(((e,t)=>{const s=indexedDB.open(this.DB_NAME,1);s.onerror=()=>t(s.error),s.onsuccess=()=>{this.db=s.result,e()},s.onupgradeneeded=e=>{const t=e.target.result;t.objectStoreNames.contains(this.STORE_NAME)||t.createObjectStore(this.STORE_NAME)}}))}loadUserCredentials(){if(!this.db)return void console.error("Database not initialized");const e=this.db.transaction(this.STORE_NAME,"readonly").objectStore(this.STORE_NAME).get("userCredentials");e.onsuccess=()=>{e.result&&(this.userCredentials=new Map(JSON.parse(e.result)))},e.onerror=()=>{console.error("Error loading user credentials:",e.error)}}saveUserCredentials(){if(!this.db)return void console.error("Database not initialized");const e=this.db.transaction(this.STORE_NAME,"readwrite").objectStore(this.STORE_NAME),t=JSON.stringify(Array.from(this.userCredentials.entries())),s=e.put(t,"userCredentials");s.onerror=()=>{console.error("Error saving user credentials:",s.error)}}calculateXPRequirement(e){return Math.floor(100*Math.pow(1.5,e-1))}initializeGameState(){for(let e=0;e<this.ENEMY_COUNT;e++)t.push(this.createEnemy());for(let e=0;e<20;e++)s.push(this.createObstacle());for(let e=0;e<100;e++)this.decorations.push(d());for(let e=0;e<50;e++)this.sands.push(h())}start(){if(!this.isRunning)try{this.signalingServer=new g;const e=8080,t="https:"===location.protocol?"wss:":"ws:";this.serverAddress=`${t}//${location.hostname}:${e}`,this.postMessage("address",{address:this.serverAddress}),this.signalingServer.onMessage((e=>{this.handleMessage(e)})),this.isRunning=!0,this.postMessage("status",{online:!0}),this.postMessage("log",`Server started successfully at ${this.serverAddress}`),this.startGameLoops()}catch(e){const t=e instanceof Error?e.message:"Unknown error";this.postMessage("log",`Failed to start server: ${t}`)}}handleMessage(e){try{switch(e.type){case"authenticate":this.handleAuthentication(e.data,e.peerId);break;case"playerMovement":this.isAuthenticated(e.peerId)&&this.handlePlayerMovement(e.data);break;case"disconnect":this.handleDisconnect(e.peerId)}}catch(e){console.error("Error handling message:",e)}}handleAuthentication(n,r){var i,o;const{username:l,password:c,playerName:d}=n;if(this.userCredentials.has(l)){if(this.userCredentials.get(l)!==c)return void(null===(i=this.signalingServer)||void 0===i||i.sendToPeer(r,{type:"authenticated",data:{success:!1,error:"Invalid credentials"}}))}else this.userCredentials.set(l,c),this.saveUserCredentials();const h=`user_${Math.random().toString(36).substr(2,9)}`,g={userId:h,username:l,playerName:d};this.authenticatedUsers.set(r,g),e[h]={id:h,name:d,x:200,y:1e3,angle:0,score:0,velocityX:0,velocityY:0,health:100,maxHealth:100,damage:5,inventory:[],loadout:Array(10).fill(null),isInvulnerable:!0,level:1,xp:0,xpToNextLevel:this.calculateXPRequirement(1)},null===(o=this.signalingServer)||void 0===o||o.sendToPeer(r,{type:"authenticated",data:{success:!0,playerId:h,gameState:{players:e,enemies:t,items:a,obstacles:s,decorations:this.decorations,sands:this.sands}}}),this.broadcast({type:"playerJoined",data:e[h]})}broadcast(e){this.signalingServer&&this.signalingServer.broadcast(e)}stop(){this.isRunning&&(this.connections.clear(),this.isRunning=!1,this.signalingServer=null,this.db&&(this.db.close(),this.db=null),this.postMessage("status",{online:!1}),this.postMessage("log","Server stopped"))}startGameLoops(){setInterval((()=>{this.moveEnemies(),this.updateStats(),this.broadcast({type:"gameState",data:{players:e,enemies:t,items:a}})}),100),setInterval((()=>{Object.values(e).forEach((e=>{e.health<e.maxHealth&&(e.health=Math.min(e.maxHealth,e.health+5))}))}),1e3)}createEnemy(){const e=Math.random()*n;let t="common";for(const[s,a]of Object.entries(o))if(e>=a.start&&e<a.end){t=s;break}const s=i[t];return{id:Math.random().toString(36).substr(2,9),type:Math.random()<.5?"octopus":"fish",tier:t,x:e,y:Math.random()*r,angle:Math.random()*Math.PI*2,health:s.health,speed:s.speed,damage:s.damage,knockbackX:0,knockbackY:0}}createObstacle(){const e=Math.random()<.3;return{id:Math.random().toString(36).substr(2,9),x:Math.random()*n,y:Math.random()*r,width:50+50*Math.random(),height:50+50*Math.random(),type:"coral",isEnemy:e,health:e?50:void 0}}moveEnemies(){}updateStats(){this.postMessage("stats",{players:Object.keys(e).length,enemies:t.length})}postMessage(e,t){self.postMessage({type:e,data:t})}handlePlayerMovement(s){const a=e[s.id];if(a){a.x=Math.max(0,Math.min(9960,s.x)),a.y=Math.max(0,Math.min(1960,s.y)),a.angle=s.angle,a.velocityX=s.velocityX,a.velocityY=s.velocityY;for(const s of t){const t=40*l[s.tier];if(a.x<s.x+t&&a.x+40>s.x&&a.y<s.y+t&&a.y+40>s.y&&!a.isInvulnerable){a.health-=s.damage;const t=s.x-a.x,n=s.y-a.y,r=Math.sqrt(t*t+n*n),i=t/r,o=n/r;a.x-=20*i,a.y-=20*o,a.health<=0&&(this.broadcast({type:"playerDied",data:{playerId:a.id}}),a.health=a.maxHealth,a.x=200,a.y=1e3,a.isInvulnerable=!0,setTimeout((()=>{e[a.id]&&(e[a.id].isInvulnerable=!1)}),3e3))}}this.broadcast({type:"playerMoved",data:a})}}isAuthenticated(e){return this.authenticatedUsers.has(e)}handleDisconnect(t){const s=this.authenticatedUsers.get(t);s&&(delete e[s.userId],this.authenticatedUsers.delete(t),this.broadcast({type:"playerDisconnected",data:{playerId:s.userId}}))}getIsRunning(){return this.isRunning}getServerAddress(){return this.serverAddress}};self.onmessage=function(e){const{type:t,data:s}=e.data;switch(t){case"start":p.start();break;case"stop":p.stop();break;case"getAddress":p.getIsRunning()&&self.postMessage({type:"address",data:{address:p.getServerAddress()}});break;default:console.warn("Unknown message type:",t)}}})();